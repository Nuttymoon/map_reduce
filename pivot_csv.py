# Purpose : pivot .csv file matrix
# My idea was to use the column indexes of the initial matrix as keys
# to gather all the cells of a column in a list,
# each list corresponding to a line in the pivoted matrix we want to write in the .csv

# Here we emulate the input reader,
# it creates a list of (key, value) from a .csv file.
# key = line index
# value = array of the cells' values in the line

import csv
with open("test.csv") as csvfile:
    # The .csv file is on the git repo
    csvreader = csv.reader(csvfile, delimiter=',')
    l = 0
    csv_lines = []
    # For each line, we generate the (key, value) pair
    for row in csvreader:
        csv_lines += [[l, row]]
        l += 1
print(csv_lines)

# Output:
# [[0, ['25', '48', '79']],
#  [1, ['54', '67', '98']],
#  [2, ['42', '35', '68']],
#  [3, ['87', '59', '74']]]

# The map function gets a (key, value) item generated by the input reader
# and the context that gathers all the mappers' results.
# It creates a new (key, value) pair and adds it to the context:
# key = cell's column index
# value = [cell's line index, cell's value]
# (We have to keep track of the line indexes to order the cells' values after the shuffle/sort)


def map_function(key, value, context):
    i = 0  # column index
    # For each cell of the .csv line
    for cell in value:
        # We add the new (key, value) to the context
        context += [[i, [key, cell]]]
        i += 1
    return


# We can see the result of the 4 maps
context1 = []
# Each line in the .csv is processed on a separate mapper
for lines in csv_lines:
    map_function(lines[0], lines[1], context1)
print(context1)

# Output:
# [[0, [0, '25']],
#  [1, [0, '48']],
#  [2, [0, '79']],
#  [0, [1, '54']],
#  [1, [1, '67']],
#  [2, [1, '98']],
#  [0, [2, '42']],
#  [1, [2, '35']],
#  [2, [2, '68']],
#  [0, [3, '87']],
#  [1, [3, '59']],
#  [2, [3, '74']]]

# The shuffle and sort happens and gives us something like that:
# [1, [[0,'48'], [2,'35'], [3,'59'], [1,'67']]] for key 1
# and the same for all the keys.
# Each (key, value) now corresponds to an ex column of the .csv
# The key is the ex column index, soon to be the line index
# Each item of 'value' is the cell position in the ex column (soon its position in the line) and its content

# For testing purposes
shuffled_1 = [1, [[0, '48'], [2, '35'], [3, '59'], [1, '67']]]

# The reduce function gets a (key, value) item generated by the shuffle/sort
# and the context that gathers all the reducers' results
# It creates a new (key, value) pair and adds it to the context
# key = line index in the pivoted matrix
# column = array of the cells' values in the line


def reduce_function(key, values, context):
    # We create a list of the size of the line
    output_value = [0]*len(values)
    # For each cell, we put it's value at the right position in the line
    for value in values:
        output_value[value[0]] = value[1]
    # We add the new (key, value) to the context
    context.append([key, output_value])
    return


# We can see the result of the reduce on the item of key 1
context2 = []
reduce_function(shuffled_1[0], shuffled_1[1], context2)
print(context2)

# Output
# [[1, ['48', '67', '35', '59']]]

# This output corresponds to the column 1 of the original matrix
# Every result of a reducer corresponds to a new line of the pivoted matrix.
# The output writer can write the pivoted matrix to the .csv file by line.
